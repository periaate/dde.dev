
	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/x-icon" href="favicon.ico">


<link rel="stylesheet" type="text/css" href="/static/css.css">

<script src="/static/js.js" defer></script>
<!--<script src="https://unpkg.com/htmx.org@2.0.1" integrity="sha384-QWGpdj554B4ETpJJC9z+ZHJcA/i59TyjxEPXiiUgN2WmTyV5OEZWCD6gQhgkdpB/" crossorigin="anonymous"></script>-->

<link rel="stylesheet" href="/static/highlight-zenburn.css">
<script src="/static/highlight.min.js"></script>
<script defer>hljs.highlightAll();</script>
		
		<title># Abstraction, not indirection</title>
		<meta property="og:title" content="# Abstraction, not indirection" >
		<meta property="og:site_name" content="dde.dev">
		<meta property="og:url" content="https://dde.dev">
		<meta property="og:description" content="undefined">
		<meta property="og:type" content="profile">
	
	</head>
	<body>
	<header>
		<a href="/" class="contrast">dde.dev</a>
<theme-toggle></theme-toggle>
	</header>
	<main>
		<h1>Abstraction, not indirection</h1>

<p>Cognitive overhead comes from indirection, not abstraction.</p>

<p>This expression is relatively abstract. Some might argue that it is hard to read, not maintainable, etc.
But in truth, this is deceptively simple. It might be higher order in the way it abstracts its logic,
but at its core, it is procedural.</p>

<pre><code class="language-go">fileNames, err := fsio.Walk(gen.Not(fsio.IsDir))(&quot;.&quot;)
</code></pre>

<p>It has just a single level of indirection. It doesn&rsquo;t hide the underlying procedures, but rather raises them to higher order of abstraction.</p>

<pre><code class="language-go">// fsio.IsDir
func IsDir(f string) bool {
	info, err := os.Stat(f)
	if err != nil {
		return false
	}
	return info.IsDir()
}
</code></pre>

<pre><code class="language-go">// gen.Not
func Not[T any](fn func(T) bool) func(T) bool {
	return func(t T) bool { return !fn(t) }
}
</code></pre>

<pre><code class="language-go">// fsio.Walk
func Walk(fn func(string) bool) func(string) (res []string, err error) {
	return func(root string) (res []string, err error) {
		err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
            
			if !fn(path) {
				return nil
			}

			res = append(res, path)
			return nil
		})

		return
	}
}
</code></pre>

<p>This isn&rsquo;t just any abstraction, but an abstraction based on tacit programming and combinatory logic.
I believe that tacit programming perfectly represents the low indirection, high abstraction paradigm.
Data and transformations are separated.</p>

<p>The value of this paradigm, in my opinion, comes from its utility in the initial stages of creating solutions.
By not needing to focus on the details, the structure, the flow of data, the algorithms and transformations, they can be fleshed out.</p>

<p>But in reality, as Rob Pike points out, this level of coupling and dependence on higher order functions isn&rsquo;t the best for performance or for maintainability.</p>

<blockquote>
    <p>A little copying is better than a little dependency â€” <cite><a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&t=568s">Rob Pike</a></cite></p>
</blockquote>

<p>Our paradigm here is very synergistic with this ideology.
Once the structure of a program is clear, it can be unwrapped, inlining the abstractions to create idiomatic, procedural code.
This is because our paradigm is not separate from the procedural paradigm, but just a higher order abstraction of it.</p>

<pre><code class="language-go">fsio.Walk(gen.Not(fsio.IsDir))(&quot;.&quot;)
</code></pre>

<p>Directly simplifies to:</p>

<pre><code class="language-go">err = filepath.Walk(&quot;.&quot;, func(path string, info os.FileInfo, err error) error {
    if err != nil || info.IsDir() {
        return err
    }

    res = append(res, path)
    return nil
})
</code></pre>

<p>Declarative programming is not purely the domain of functional programming. If anything, it has great affinity to procedural code, as, what is a procedure but a piece of logic?
The &ldquo;purity&rdquo; of that logic is inconsequential to the role and outcome of that logic.</p>

<p>Procedures are de facto declarative. For example, <code>map</code> is just a procedure over an array with a function. Internalizing this enables you to approach procedures from the perspective of defining logic over data using another function. This is what <code>map</code> is at its core. A procedure which simply describes the way in which a transformation is applied over data. Whether it is &ldquo;functional&rdquo; or &ldquo;pure&rdquo; is irrelevant to its nature. It&rsquo;s nothing but an implementation detail.</p>
	</main>
	<footer>
		<small>Contact me: <a href="mailto:daniel@saury.fi">daniel@saury.fi</a></small>
	</footer>
	</body>
	</html>
	